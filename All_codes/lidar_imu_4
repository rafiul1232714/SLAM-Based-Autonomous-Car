#!/usr/bin/env python3
"""
IMU + LiDAR drift-corrected 2D EKF (Raspberry Pi)

What this does:
- IMU thread (~100 Hz): MPU6050 + HMC5883L -> Madgwick -> yaw + world-frame accel -> EKF predict (x,y,vx,vy)
- LiDAR thread (~5–10 Hz): RPLidar full scans -> ICP (scan-to-scan) -> world-frame delta using yaw -> LiDAR odom (xL,yL)
  -> EKF update to correct x,y drift
- Debug prints show exactly what LiDAR is doing (dx,dy,dtheta,fit, world delta, EKF correction amounts)

Requirements (inside your venv):
  pip install rplidar-roboticia numpy smbus2

Also recommended (system):
  sudo apt install -y i2c-tools
  enable I2C via raspi-config

Port:
  /dev/ttyUSB0 (you already confirmed)
"""

import time
import math
import threading
import numpy as np

# Use smbus2 in venv
from smbus2 import SMBus

from rplidar import RPLidar


# =========================
#   CONFIG
# =========================
I2C_BUS = 1
MPU_ADDR = 0x68
MAG_ADDR = 0x1E  # HMC5883L

G = 9.80665

LIDAR_PORT = "/dev/ttyUSB0"
LIDAR_MIN_MM = 150
LIDAR_MAX_MM = 8000
LIDAR_MIN_Q = 8

SCAN_MIN_POINTS = 180
DOWNSAMPLE_N = 250

# EKF tuning
Q_POS = 0.15         # process noise position
Q_VEL = 0.70         # process noise velocity
R_LIDAR_POS = 0.10   # meters: bigger => trust LiDAR less

# IMU loop
IMU_HZ = 100
MADGWICK_BETA = 0.08

# ICP gating
ICP_FIT_GATE = 0.05           # ignore ICP updates if fit worse than this
ICP_MAX_CORR_DIST = 0.40      # meters


# =========================
#   Helpers
# =========================
def twos16(v: int) -> int:
    return v - 65536 if v & 0x8000 else v

def clamp(x: float, a: float, b: float) -> float:
    return a if x < a else b if x > b else x

def rot2(theta: float) -> np.ndarray:
    c, s = math.cos(theta), math.sin(theta)
    return np.array([[c, -s],
                     [s,  c]], dtype=float)

def polar_to_xy(angle_deg: float, dist_mm: float) -> tuple[float, float]:
    a = math.radians(angle_deg)
    r = dist_mm / 1000.0
    return r * math.cos(a), r * math.sin(a)

def downsample_points(pts: np.ndarray, n: int = DOWNSAMPLE_N) -> np.ndarray:
    if len(pts) <= n:
        return pts
    idx = np.random.choice(len(pts), n, replace=False)
    return pts[idx]


# =========================
#   MPU6050
# =========================
class MPU6050:
    def __init__(self, bus: SMBus, addr: int = MPU_ADDR):
        self.bus = bus
        self.addr = addr

        # Wake up
        self.bus.write_byte_data(self.addr, 0x6B, 0x00)
        time.sleep(0.05)

        # Gyro ±250 dps, Acc ±2g
        self.bus.write_byte_data(self.addr, 0x1B, 0x00)
        self.bus.write_byte_data(self.addr, 0x1C, 0x00)
        time.sleep(0.01)

        # Enable I2C bypass so mag @0x1E is visible
        self.bus.write_byte_data(self.addr, 0x37, 0x02)  # BYPASS_EN=1
        self.bus.write_byte_data(self.addr, 0x6A, 0x00)  # disable I2C master
        time.sleep(0.01)

        self.acc_lsb_per_g = 16384.0
        self.gyro_lsb_per_dps = 131.0

        self.gyro_bias_dps = np.zeros(3)
        self.acc_bias_g = np.zeros(3)

    def _read_i16(self, reg: int) -> int:
        hi = self.bus.read_byte_data(self.addr, reg)
        lo = self.bus.read_byte_data(self.addr, reg + 1)
        return twos16((hi << 8) | lo)

    def read(self) -> tuple[np.ndarray, np.ndarray]:
        ax = self._read_i16(0x3B)
        ay = self._read_i16(0x3D)
        az = self._read_i16(0x3F)
        gx = self._read_i16(0x43)
        gy = self._read_i16(0x45)
        gz = self._read_i16(0x47)

        acc_g = np.array([ax, ay, az], dtype=float) / self.acc_lsb_per_g
        gyro_dps = np.array([gx, gy, gz], dtype=float) / self.gyro_lsb_per_dps

        acc_g -= self.acc_bias_g
        gyro_dps -= self.gyro_bias_dps

        gyro_rads = np.deg2rad(gyro_dps)
        return acc_g, gyro_rads

    def calibrate(self, seconds: float = 3.0, hz: int = 200) -> None:
        n = int(seconds * hz)
        acc_sum = np.zeros(3)
        gyro_sum_dps = np.zeros(3)
        dt = 1.0 / hz

        print(f"[cal] Hold IMU still for {seconds:.1f}s ...")
        for _ in range(n):
            acc_g, gyro_rads = self.read()
            acc_sum += acc_g
            gyro_sum_dps += np.rad2deg(gyro_rads)
            time.sleep(dt)

        acc_mean = acc_sum / n
        gyro_mean_dps = gyro_sum_dps / n

        self.gyro_bias_dps = gyro_mean_dps
        self.acc_bias_g = np.array([acc_mean[0], acc_mean[1], acc_mean[2] - 1.0])

        print("[cal] gyro_bias_dps:", self.gyro_bias_dps)
        print("[cal] acc_bias_g:", self.acc_bias_g)


# =========================
#   HMC5883L
# =========================
class HMC5883L:
    def __init__(self, bus: SMBus, addr: int = MAG_ADDR):
        self.bus = bus
        self.addr = addr

        try:
            ida = self.bus.read_byte_data(self.addr, 0x0A)
            idb = self.bus.read_byte_data(self.addr, 0x0B)
            idc = self.bus.read_byte_data(self.addr, 0x0C)
            print("[mag] ID:", chr(ida), chr(idb), chr(idc))
        except Exception as e:
            print("[mag] ID read failed (may still work):", e)

        # config
        self.bus.write_byte_data(self.addr, 0x00, 0x70)  # 8avg, 15Hz
        self.bus.write_byte_data(self.addr, 0x01, 0x20)  # gain
        self.bus.write_byte_data(self.addr, 0x02, 0x00)  # continuous
        time.sleep(0.01)

        self.offset = np.zeros(3)  # optional calibration later
        self.axis_map = np.array([0, 1, 2])
        self.axis_sign = np.array([1, 1, 1])

        print(f"[mag] HMC5883L ready at 0x{self.addr:02X}")

    def read_raw(self) -> np.ndarray:
        data = self.bus.read_i2c_block_data(self.addr, 0x03, 6)
        x = twos16((data[0] << 8) | data[1])
        z = twos16((data[2] << 8) | data[3])
        y = twos16((data[4] << 8) | data[5])
        return np.array([x, y, z], dtype=float)

    def read(self) -> np.ndarray:
        m = self.read_raw()
        m = (m - self.offset)
        m = m[self.axis_map] * self.axis_sign
        return m


# =========================
#   Madgwick AHRS
# =========================
class MadgwickAHRS:
    def __init__(self, beta: float = MADGWICK_BETA):
        self.beta = beta
        self.q = np.array([1.0, 0.0, 0.0, 0.0], dtype=float)  # [w,x,y,z]

    def update(self, gx, gy, gz, ax, ay, az, mx, my, mz, dt) -> None:
        # Normalize accel
        norm = math.sqrt(ax*ax + ay*ay + az*az)
        if norm < 1e-9:
            return
        ax, ay, az = ax/norm, ay/norm, az/norm

        # Normalize mag
        norm = math.sqrt(mx*mx + my*my + mz*mz)
        if norm < 1e-9:
            return
        mx, my, mz = mx/norm, my/norm, mz/norm

        q1, q2, q3, q4 = self.q

        hx = 2*mx*(0.5 - q3*q3 - q4*q4) + 2*my*(q2*q3 - q1*q4) + 2*mz*(q2*q4 + q1*q3)
        hy = 2*mx*(q2*q3 + q1*q4) + 2*my*(0.5 - q2*q2 - q4*q4) + 2*mz*(q3*q4 - q1*q2)
        bx = math.sqrt(hx*hx + hy*hy)
        bz = 2*mx*(q2*q4 - q1*q3) + 2*my*(q3*q4 + q1*q2) + 2*mz*(0.5 - q2*q2 - q3*q3)

        f1 = 2*(q2*q4 - q1*q3) - ax
        f2 = 2*(q1*q2 + q3*q4) - ay
        f3 = 2*(0.5 - q2*q2 - q3*q3) - az
        f4 = 2*bx*(0.5 - q3*q3 - q4*q4) + 2*bz*(q2*q4 - q1*q3) - mx
        f5 = 2*bx*(q2*q3 - q1*q4) + 2*bz*(q1*q2 + q3*q4) - my
        f6 = 2*bx*(q1*q3 + q2*q4) + 2*bz*(0.5 - q2*q2 - q3*q3) - mz

        s1 = (-2*q3)*f1 + (2*q2)*f2 + (-2*bz*q3)*f4 + (-2*bx*q4 + 2*bz*q2)*f5 + (2*bx*q3)*f6
        s2 = (2*q4)*f1 + (2*q1)*f2 + (-4*q2)*f3 + (2*bz*q4)*f4 + (2*bx*q3 + 2*bz*q1)*f5 + (2*bx*q4 - 4*bz*q2)*f6
        s3 = (-2*q1)*f1 + (2*q4)*f2 + (-4*q3)*f3 + (-4*bx*q3 - 2*bz*q1)*f4 + (2*bx*q2 + 2*bz*q4)*f5 + (2*bx*q1 - 4*bz*q3)*f6
        s4 = (2*q2)*f1 + (2*q3)*f2 + (-2*bx*q4 + 2*bz*q2)*f4 + (-2*bx*q1 + 2*bz*q3)*f5 + (2*bx*q2)*f6

        norm_s = math.sqrt(s1*s1 + s2*s2 + s3*s3 + s4*s4)
        if norm_s > 1e-9:
            s1, s2, s3, s4 = s1/norm_s, s2/norm_s, s3/norm_s, s4/norm_s

        qDot1 = 0.5 * (-q2*gx - q3*gy - q4*gz) - self.beta*s1
        qDot2 = 0.5 * ( q1*gx + q3*gz - q4*gy) - self.beta*s2
        qDot3 = 0.5 * ( q1*gy - q2*gz + q4*gx) - self.beta*s3
        qDot4 = 0.5 * ( q1*gz + q2*gy - q3*gx) - self.beta*s4

        q1 += qDot1 * dt
        q2 += qDot2 * dt
        q3 += qDot3 * dt
        q4 += qDot4 * dt

        norm_q = math.sqrt(q1*q1 + q2*q2 + q3*q3 + q4*q4)
        self.q = np.array([q1, q2, q3, q4]) / norm_q

    def euler(self) -> tuple[float, float, float]:
        w, x, y, z = self.q
        sinr = 2*(w*x + y*z)
        cosr = 1 - 2*(x*x + y*y)
        roll = math.atan2(sinr, cosr)

        sinp = 2*(w*y - z*x)
        pitch = math.asin(clamp(sinp, -1, 1))

        siny = 2*(w*z + x*y)
        cosy = 1 - 2*(y*y + z*z)
        yaw = math.atan2(siny, cosy)
        return roll, pitch, yaw

    def rotmat(self) -> np.ndarray:
        w, x, y, z = self.q
        return np.array([
            [1-2*(y*y+z*z), 2*(x*y - z*w), 2*(x*z + y*w)],
            [2*(x*y + z*w), 1-2*(x*x+z*z), 2*(y*z - x*w)],
            [2*(x*z - y*w), 2*(y*z + x*w), 1-2*(x*x+y*y)]
        ], dtype=float)


# =========================
#   EKF: state [x,y,vx,vy]
# =========================
class EKF2D:
    def __init__(self):
        self.x = np.zeros((4, 1))
        self.P = np.diag([1.0, 1.0, 1.0, 1.0])**2

        self.q_pos = Q_POS
        self.q_vel = Q_VEL

    def predict(self, ax_w: float, ay_w: float, dt: float) -> None:
        x, y, vx, vy = self.x.flatten()

        x  = x  + vx*dt + 0.5*ax_w*dt*dt
        y  = y  + vy*dt + 0.5*ay_w*dt*dt
        vx = vx + ax_w*dt
        vy = vy + ay_w*dt

        self.x = np.array([[x], [y], [vx], [vy]])

        F = np.eye(4)
        F[0, 2] = dt
        F[1, 3] = dt

        Q = np.diag([self.q_pos, self.q_pos, self.q_vel, self.q_vel])**2
        self.P = F @ self.P @ F.T + Q

    def update_lidar_xy(self, x_meas: float, y_meas: float, r_pos: float = R_LIDAR_POS) -> None:
        z = np.array([[x_meas], [y_meas]])
        H = np.zeros((2, 4))
        H[0, 0] = 1.0
        H[1, 1] = 1.0

        R = np.diag([r_pos, r_pos])**2
        y = z - (H @ self.x)
        S = H @ self.P @ H.T + R
        K = self.P @ H.T @ np.linalg.inv(S)

        self.x = self.x + K @ y
        self.P = (np.eye(4) - K @ H) @ self.P


# =========================
#   ICP 2D
# =========================
def icp_2d(prev_pts: np.ndarray, curr_pts: np.ndarray, iters: int = 8, max_corr_dist: float = ICP_MAX_CORR_DIST):
    src = prev_pts.copy()
    dst = curr_pts.copy()

    T = np.eye(3)

    if len(src) < 50 or len(dst) < 50:
        return 0.0, 0.0, 0.0, 999.0

    src = downsample_points(src)
    dst = downsample_points(dst)

    def nearest_neighbors(a: np.ndarray, b: np.ndarray):
        idx = []
        d2s = []
        for p in a:
            d2 = np.sum((b - p)**2, axis=1)
            j = int(np.argmin(d2))
            idx.append(j)
            d2s.append(d2[j])
        return np.array(idx), np.array(d2s)

    fitness = 999.0
    for _ in range(iters):
        idx, d2 = nearest_neighbors(src, dst)
        dist = np.sqrt(d2)

        mask = dist < max_corr_dist
        if np.sum(mask) < 30:
            break

        A = src[mask]
        B = dst[idx[mask]]

        ca = A.mean(axis=0)
        cb = B.mean(axis=0)
        AA = A - ca
        BB = B - cb

        H = AA.T @ BB
        U, _, Vt = np.linalg.svd(H)
        R = Vt.T @ U.T
        if np.linalg.det(R) < 0:
            Vt[1, :] *= -1
            R = Vt.T @ U.T

        t = cb - R @ ca

        src = (R @ src.T).T + t

        Ti = np.eye(3)
        Ti[:2, :2] = R
        Ti[:2, 2] = t
        T = Ti @ T

        fitness = float(np.mean(dist[mask]))

    dx = float(T[0, 2])
    dy = float(T[1, 2])
    dtheta = math.atan2(float(T[1, 0]), float(T[0, 0]))
    return dx, dy, dtheta, fitness


# =========================
#   LiDAR scan processing
# =========================
def scan_to_points(scan) -> np.ndarray | None:
    """
    scan: list of tuples (quality, angle, distance_mm)
    returns: Nx2 points in meters in LiDAR frame
    """
    pts = []
    for quality, angle, dist in scan:
        if quality < LIDAR_MIN_Q:
            continue
        if dist <= 0:
            continue
        if dist < LIDAR_MIN_MM or dist > LIDAR_MAX_MM:
            continue
        x, y = polar_to_xy(angle, dist)
        pts.append([x, y])

    if len(pts) < SCAN_MIN_POINTS:
        return None
    return np.array(pts, dtype=float)


def lidar_scan_iterator(lidar: RPLidar):
    """
    Compatibility layer for different rplidar versions.
    Preferred: iter_scans()
    Fallback: iter_measures() that yields (new_scan, quality, angle, distance)
    """
    if hasattr(lidar, "iter_scans"):
        for scan in lidar.iter_scans():
            yield scan
    elif hasattr(lidar, "iter_measures"):
        buf = []
        for new_scan, quality, angle, distance in lidar.iter_measures():
            buf.append((quality, angle, distance))
            if new_scan and buf:
                yield buf
                buf = []
    else:
        raise RuntimeError("Your rplidar package has no iter_scans or iter_measures.")


# =========================
#   Shared state (thread-safe)
# =========================
class Shared:
    def __init__(self):
        self.lock = threading.Lock()
        self.roll = 0.0
        self.pitch = 0.0
        self.yaw = 0.0
        self.ax_w = 0.0
        self.ay_w = 0.0


# =========================
#   IMU thread
# =========================
def imu_loop(stop_evt: threading.Event, shared: Shared, ekf: EKF2D):
    bus = SMBus(I2C_BUS)
    imu = MPU6050(bus)
    imu.calibrate(seconds=3.0, hz=200)
    mag = HMC5883L(bus, addr=MAG_ADDR)
    ahrs = MadgwickAHRS(beta=MADGWICK_BETA)

    dt_target = 1.0 / IMU_HZ
    last = time.time()

    print("[imu] Running IMU loop...")

    while not stop_evt.is_set():
        now = time.time()
        dt = now - last
        if dt <= 0 or dt > 0.2:
            dt = dt_target
        last = now

        try:
            acc_g, gyro_rads = imu.read()
            mx, my, mz = mag.read()

            ax, ay, az = acc_g
            gx, gy, gz = gyro_rads

            ahrs.update(gx, gy, gz, ax, ay, az, mx, my, mz, dt)
            roll, pitch, yaw = ahrs.euler()
            R_bw = ahrs.rotmat()  # body->world

            acc_ms2_body = np.array([ax, ay, az], dtype=float) * G
            acc_ms2_world = R_bw @ acc_ms2_body
            acc_ms2_world[2] -= G  # remove gravity in world z

            ax_w = float(acc_ms2_world[0])
            ay_w = float(acc_ms2_world[1])

            with shared.lock:
                shared.roll = roll
                shared.pitch = pitch
                shared.yaw = yaw
                shared.ax_w = ax_w
                shared.ay_w = ay_w

            # EKF predict with IMU accel
            ekf.predict(ax_w=ax_w, ay_w=ay_w, dt=dt)

        except Exception as e:
            print("[imu] Error:", e)

        # maintain loop rate
        t_spent = time.time() - now
        to_sleep = dt_target - t_spent
        if to_sleep > 0:
            time.sleep(to_sleep)

    print("[imu] Stopped.")


# =========================
#   LiDAR thread
# =========================
def lidar_loop(stop_evt: threading.Event, shared: Shared, ekf: EKF2D):
    lidar = RPLidar(LIDAR_PORT)
    print("[lidar] info:", lidar.get_info())
    print("[lidar] health:", lidar.get_health())
    print("[lidar] Running scan loop... (Ctrl+C in main stops)")

    prev_pts = None

    # LiDAR odometry pose (world frame)
    x_l = 0.0
    y_l = 0.0

    # print limiter
    last_print = 0.0

    try:
        for scan in lidar_scan_iterator(lidar):
            if stop_evt.is_set():
                break

            pts = scan_to_points(scan)
            if pts is None:
                continue

            now = time.time()

            if prev_pts is not None:
                dx, dy, dth, fit = icp_2d(prev_pts, pts, iters=8, max_corr_dist=ICP_MAX_CORR_DIST)

                with shared.lock:
                    yaw = shared.yaw

                # LiDAR frame delta -> world frame delta using yaw
                d_world = rot2(yaw) @ np.array([dx, dy], dtype=float)
                dxW, dyW = float(d_world[0]), float(d_world[1])

                # accumulate LiDAR odom
                x_l += dxW
                y_l += dyW

                # measure EKF correction amount (debug)
                x_before = float(ekf.x[0, 0])
                y_before = float(ekf.x[1, 0])

                # Gate bad ICP updates (stability!)
                if fit < ICP_FIT_GATE:
                    # optional: adaptive trust based on fit (uncomment if you want)
                    # r = clamp(fit * 5.0, 0.05, 0.30)
                    # ekf.update_lidar_xy(x_l, y_l, r_pos=r)
                    ekf.update_lidar_xy(x_l, y_l, r_pos=R_LIDAR_POS)

                x_after = float(ekf.x[0, 0])
                y_after = float(ekf.x[1, 0])

                corr_dx = x_after - x_before
                corr_dy = y_after - y_before

                # Print debug ~5 Hz
                if now - last_print > 0.2:
                    last_print = now
                    X = ekf.x.flatten()
                    print(
                        f"[ekf] x={X[0]:7.2f} y={X[1]:7.2f} vx={X[2]:6.2f} vy={X[3]:6.2f} | "
                        f"[lidar_pose] xL={x_l:7.2f} yL={y_l:7.2f} fit={fit:5.3f} yaw={math.degrees(yaw):6.1f} | "
                        f"[icp] dx={dx:+.3f} dy={dy:+.3f} dth={math.degrees(dth):+.2f}deg -> "
                        f"dxW={dxW:+.3f} dyW={dyW:+.3f} | "
                        f"[ekf_corr] corr_dx={corr_dx:+.4f} corr_dy={corr_dy:+.4f}"
                    )

            prev_pts = pts

    except Exception as e:
        print("[lidar] Error:", e)

    finally:
        try:
            lidar.stop()
            lidar.stop_motor()
            lidar.disconnect()
        except Exception:
            pass
        print("[lidar] Stopped.")


# =========================
#   Main
# =========================
def main():
    shared = Shared()
    ekf = EKF2D()
    stop_evt = threading.Event()

    t_imu = threading.Thread(target=imu_loop, args=(stop_evt, shared, ekf), daemon=True)
    t_lidar = threading.Thread(target=lidar_loop, args=(stop_evt, shared, ekf), daemon=True)

    t_imu.start()
    time.sleep(0.5)  # allow yaw to initialize
    t_lidar.start()

    print("\n[run] Running. Press Ctrl+C to stop.\n")
    try:
        while True:
            time.sleep(0.5)
    except KeyboardInterrupt:
        print("\n[run] Stopping...")
        stop_evt.set()
        time.sleep(0.5)

    print("[run] Done.")


if __name__ == "__main__":
    main()
