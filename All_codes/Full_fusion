#!/usr/bin/env python3
import time, math, re
import numpy as np
import smbus
import serial

# =========================
#   Hardware / Ports
# =========================
I2C_BUS = 1
MPU_ADDR = 0x68

MAG_ADDR = 0x1E  # <-- you confirmed 0x1E (HMC5883L)

GPS_PORT = "/dev/serial0"
GPS_BAUD = 9600

# =========================
#   Helpers
# =========================
def twos16(v):
    return v - 65536 if v & 0x8000 else v

def clamp(x, a, b):
    return a if x < a else b if x > b else x

# =========================
#   MPU6050 (Accel+Gyro)
#   + BYPASS for external mag on GY-87
# =========================
class MPU6050:
    def __init__(self, bus, addr=MPU_ADDR):
        self.bus = bus
        self.addr = addr

        # Wake up
        self.bus.write_byte_data(self.addr, 0x6B, 0x00)
        time.sleep(0.05)

        # Gyro ±250 dps, Acc ±2g
        self.bus.write_byte_data(self.addr, 0x1B, 0x00)
        self.bus.write_byte_data(self.addr, 0x1C, 0x00)
        time.sleep(0.01)

        # Enable I2C bypass so HMC5883L @ 0x1E is visible on I2C bus
        # INT_PIN_CFG (0x37): BYPASS_EN=1 (bit1)
        # USER_CTRL   (0x6A): disable I2C master mode
        self.bus.write_byte_data(self.addr, 0x37, 0x02)
        self.bus.write_byte_data(self.addr, 0x6A, 0x00)
        time.sleep(0.01)

        # Scale factors
        self.acc_lsb_per_g = 16384.0
        self.gyro_lsb_per_dps = 131.0

        self.gyro_bias_dps = np.zeros(3)
        self.acc_bias_g = np.zeros(3)

    def _read_i16(self, reg):
        hi = self.bus.read_byte_data(self.addr, reg)
        lo = self.bus.read_byte_data(self.addr, reg + 1)
        return twos16((hi << 8) | lo)

    def read(self):
        ax = self._read_i16(0x3B)
        ay = self._read_i16(0x3D)
        az = self._read_i16(0x3F)
        gx = self._read_i16(0x43)
        gy = self._read_i16(0x45)
        gz = self._read_i16(0x47)

        acc_g = np.array([ax, ay, az], dtype=float) / self.acc_lsb_per_g
        gyro_dps = np.array([gx, gy, gz], dtype=float) / self.gyro_lsb_per_dps

        acc_g -= self.acc_bias_g
        gyro_dps -= self.gyro_bias_dps

        gyro_rads = np.deg2rad(gyro_dps)
        return acc_g, gyro_rads

    def calibrate(self, seconds=3.0, hz=200):
        n = int(seconds * hz)
        acc_sum = np.zeros(3)
        gyro_sum = np.zeros(3)
        dt = 1.0 / hz

        print(f"[cal] Hold IMU still for {seconds:.1f}s ...")
        for _ in range(n):
            acc_g, gyro_rads = self.read()
            acc_sum += acc_g
            gyro_sum += np.rad2deg(gyro_rads)
            time.sleep(dt)

        acc_mean = acc_sum / n
        gyro_mean_dps = gyro_sum / n

        self.gyro_bias_dps = gyro_mean_dps
        self.acc_bias_g = np.array([acc_mean[0], acc_mean[1], acc_mean[2] - 1.0])

        print("[cal] gyro_bias_dps:", self.gyro_bias_dps)
        print("[cal] acc_bias_g:", self.acc_bias_g)

# =========================
#   HMC5883L Magnetometer (0x1E)
# =========================
class HMC5883L:
    def __init__(self, bus, addr=MAG_ADDR):
        self.bus = bus
        self.addr = addr

        # Optional: ID check (often "H43", but some clones differ)
        try:
            ida = self.bus.read_byte_data(self.addr, 0x0A)
            idb = self.bus.read_byte_data(self.addr, 0x0B)
            idc = self.bus.read_byte_data(self.addr, 0x0C)
            print("[mag] ID:", chr(ida), chr(idb), chr(idc))
        except Exception as e:
            print("[mag] ID read failed (still may work):", e)

        # Config A: 8-sample average, 15 Hz, normal measurement
        self.bus.write_byte_data(self.addr, 0x00, 0x70)
        # Config B: gain (1.3 Ga) -> 0x20
        self.bus.write_byte_data(self.addr, 0x01, 0x20)
        # Mode: continuous measurement
        self.bus.write_byte_data(self.addr, 0x02, 0x00)
        time.sleep(0.01)

        # Hard-iron offsets (CALIBRATE THESE)
        self.offset = np.zeros(3)

        # Axis alignment controls (change ONLY if yaw looks wrong)
        self.axis_map = np.array([0, 1, 2])   # [mx,my,mz] -> reorder
        self.axis_sign = np.array([1, 1, 1])  # sign flips

        print(f"[mag] HMC5883L ready at 0x{self.addr:02X}")

    def read_raw(self):
        # Data: X,Z,Y each 16-bit from 0x03
        data = self.bus.read_i2c_block_data(self.addr, 0x03, 6)
        x = twos16((data[0] << 8) | data[1])
        z = twos16((data[2] << 8) | data[3])
        y = twos16((data[4] << 8) | data[5])
        return np.array([x, y, z], dtype=float)

    def read(self):
        m = self.read_raw()
        m = m - self.offset
        m = m[self.axis_map] * self.axis_sign
        return m

# =========================
#   Madgwick AHRS (gyro+acc+mag)
# =========================
class MadgwickAHRS:
    def __init__(self, beta=0.08):
        self.beta = beta
        self.q = np.array([1.0, 0.0, 0.0, 0.0], dtype=float)  # [w,x,y,z]

    def update(self, gx, gy, gz, ax, ay, az, mx, my, mz, dt):
        # Normalize accelerometer
        norm = math.sqrt(ax*ax + ay*ay + az*az)
        if norm < 1e-9:
            return
        ax, ay, az = ax/norm, ay/norm, az/norm

        # Normalize magnetometer
        norm = math.sqrt(mx*mx + my*my + mz*mz)
        if norm < 1e-9:
            return
        mx, my, mz = mx/norm, my/norm, mz/norm

        q1, q2, q3, q4 = self.q  # w,x,y,z

        # Reference direction of magnetic field
        hx = 2*mx*(0.5 - q3*q3 - q4*q4) + 2*my*(q2*q3 - q1*q4) + 2*mz*(q2*q4 + q1*q3)
        hy = 2*mx*(q2*q3 + q1*q4) + 2*my*(0.5 - q2*q2 - q4*q4) + 2*mz*(q3*q4 - q1*q2)
        bx = math.sqrt(hx*hx + hy*hy)
        bz = 2*mx*(q2*q4 - q1*q3) + 2*my*(q3*q4 + q1*q2) + 2*mz*(0.5 - q2*q2 - q3*q3)

        # Objective function
        f1 = 2*(q2*q4 - q1*q3) - ax
        f2 = 2*(q1*q2 + q3*q4) - ay
        f3 = 2*(0.5 - q2*q2 - q3*q3) - az
        f4 = 2*bx*(0.5 - q3*q3 - q4*q4) + 2*bz*(q2*q4 - q1*q3) - mx
        f5 = 2*bx*(q2*q3 - q1*q4) + 2*bz*(q1*q2 + q3*q4) - my
        f6 = 2*bx*(q1*q3 + q2*q4) + 2*bz*(0.5 - q2*q2 - q3*q3) - mz

        # Gradient
        s1 = (-2*q3)*f1 + (2*q2)*f2 + (-2*bz*q3)*f4 + (-2*bx*q4 + 2*bz*q2)*f5 + (2*bx*q3)*f6
        s2 = (2*q4)*f1 + (2*q1)*f2 + (-4*q2)*f3 + (2*bz*q4)*f4 + (2*bx*q3 + 2*bz*q1)*f5 + (2*bx*q4 - 4*bz*q2)*f6
        s3 = (-2*q1)*f1 + (2*q4)*f2 + (-4*q3)*f3 + (-4*bx*q3 - 2*bz*q1)*f4 + (2*bx*q2 + 2*bz*q4)*f5 + (2*bx*q1 - 4*bz*q3)*f6
        s4 = (2*q2)*f1 + (2*q3)*f2 + (-2*bx*q4 + 2*bz*q2)*f4 + (-2*bx*q1 + 2*bz*q3)*f5 + (2*bx*q2)*f6

        norm_s = math.sqrt(s1*s1 + s2*s2 + s3*s3 + s4*s4)
        if norm_s > 1e-9:
            s1, s2, s3, s4 = s1/norm_s, s2/norm_s, s3/norm_s, s4/norm_s

        # Integrate quaternion rate
        qDot1 = 0.5 * (-q2*gx - q3*gy - q4*gz) - self.beta*s1
        qDot2 = 0.5 * ( q1*gx + q3*gz - q4*gy) - self.beta*s2
        qDot3 = 0.5 * ( q1*gy - q2*gz + q4*gx) - self.beta*s3
        qDot4 = 0.5 * ( q1*gz + q2*gy - q3*gx) - self.beta*s4

        q1 += qDot1 * dt
        q2 += qDot2 * dt
        q3 += qDot3 * dt
        q4 += qDot4 * dt

        norm_q = math.sqrt(q1*q1 + q2*q2 + q3*q3 + q4*q4)
        self.q = np.array([q1, q2, q3, q4]) / norm_q

    def euler(self):
        w, x, y, z = self.q

        sinr = 2*(w*x + y*z)
        cosr = 1 - 2*(x*x + y*y)
        roll = math.atan2(sinr, cosr)

        sinp = 2*(w*y - z*x)
        pitch = math.asin(clamp(sinp, -1, 1))

        siny = 2*(w*z + x*y)
        cosy = 1 - 2*(y*y + z*z)
        yaw = math.atan2(siny, cosy)
        return roll, pitch, yaw

    def rotmat(self):
        w, x, y, z = self.q
        return np.array([
            [1-2*(y*y+z*z), 2*(x*y - z*w), 2*(x*z + y*w)],
            [2*(x*y + z*w), 1-2*(x*x+z*z), 2*(y*z - x*w)],
            [2*(x*z - y*w), 2*(y*z + x*w), 1-2*(x*x+y*y)]
        ], dtype=float)

# =========================
#   GPS (NMEA) minimal
# =========================
_NMEA = re.compile(r"^\$(?P<body>[^*]+)\*(?P<chk>[0-9A-Fa-f]{2})$")

def nmea_checksum(body: str) -> int:
    x = 0
    for c in body:
        x ^= ord(c)
    return x

def parse_nmea(line: str):
    m = _NMEA.match(line.strip())
    if not m:
        return None, None
    body = m["body"]
    got = int(m["chk"], 16)
    if nmea_checksum(body) != got:
        return None, None
    parts = body.split(",")
    return parts[0], parts

def latlon(v, hemi):
    if not v or "." not in v:
        return None
    d = 2 if hemi in ("N", "S") else 3
    deg = int(v[:d])
    mins = float(v[d:])
    out = deg + mins / 60.0
    return -out if hemi in ("S", "W") else out

class GPSReader:
    def __init__(self, port=GPS_PORT, baud=GPS_BAUD):
        self.ser = serial.Serial(port, baud, timeout=0.2)
        self.last_fix = None

    def read_once(self):
        line = self.ser.readline().decode("ascii", errors="ignore").strip()
        if not line:
            return None
        kind, p = parse_nmea(line)
        if not kind:
            return None

        if kind.endswith("GGA"):
            fixQ = p[6] if len(p) > 6 else "0"
            sats = int(p[7]) if len(p) > 7 and p[7] else 0
            hdop = float(p[8]) if len(p) > 8 and p[8] else None
            utc = p[1] if len(p) > 1 else None
            if fixQ != "0":
                lat = latlon(p[2], p[3])
                lon = latlon(p[4], p[5])
                self._update(lat=lat, lon=lon, sats=sats, hdop=hdop, utc=utc)

        if kind.endswith("RMC"):
            utc = p[1] if len(p) > 1 else None
            status = p[2] if len(p) > 2 else "V"
            if status == "A":
                lat = latlon(p[3], p[4])
                lon = latlon(p[5], p[6])
                spd_kmh = float(p[7]) * 1.852 if len(p) > 7 and p[7] else 0.0
                cog = float(p[8]) if len(p) > 8 and p[8] else None
                self._update(lat=lat, lon=lon, spd_kmh=spd_kmh, cog_deg=cog, utc=utc)

        return self.last_fix

    def _update(self, **kw):
        if self.last_fix is None:
            self.last_fix = {}
        for k, v in kw.items():
            if v is not None:
                self.last_fix[k] = v

# =========================
#   Lat/Lon -> Local XY (meters)
# =========================
class LocalFrame:
    def __init__(self):
        self.lat0 = None
        self.lon0 = None

    def set_origin(self, lat, lon):
        self.lat0 = lat
        self.lon0 = lon

    def ll_to_xy(self, lat, lon):
        R = 6378137.0
        lat0 = math.radians(self.lat0)
        x = math.radians(lon - self.lon0) * R * math.cos(lat0)
        y = math.radians(lat - self.lat0) * R
        return x, y

# =========================
#   EKF 2D: state [x,y,vx,vy,yaw]
# =========================
class EKF2D:
    def __init__(self):
        self.x = np.zeros((5, 1))
        self.P = np.diag([10, 10, 5, 5, 0.5])**2

        self.q_pos = 0.05
        self.q_vel = 0.5
        self.q_yaw = 0.02

        self.r_gps = 3.0
        self.r_cog = math.radians(10.0)

    def predict(self, ax_w, ay_w, yaw, dt):
        x, y, vx, vy, psi = self.x.flatten()
        x  = x  + vx*dt + 0.5*ax_w*dt*dt
        y  = y  + vy*dt + 0.5*ay_w*dt*dt
        vx = vx + ax_w*dt
        vy = vy + ay_w*dt
        psi = yaw
        self.x = np.array([[x], [y], [vx], [vy], [psi]])

        F = np.eye(5)
        F[0, 2] = dt
        F[1, 3] = dt

        Q = np.diag([self.q_pos, self.q_pos, self.q_vel, self.q_vel, self.q_yaw])**2
        self.P = F @ self.P @ F.T + Q

    def update_gps_xy(self, x_gps, y_gps):
        z = np.array([[x_gps], [y_gps]])
        H = np.zeros((2, 5))
        H[0, 0] = 1.0
        H[1, 1] = 1.0
        R = np.diag([self.r_gps, self.r_gps])**2

        y = z - (H @ self.x)
        S = H @ self.P @ H.T + R
        K = self.P @ H.T @ np.linalg.inv(S)
        self.x = self.x + K @ y
        self.P = (np.eye(5) - K @ H) @ self.P

    def update_yaw_from_cog(self, cog_deg):
        psi_meas = math.radians(cog_deg)
        psi = float(self.x[4, 0])
        d = (psi_meas - psi + math.pi) % (2*math.pi) - math.pi

        H = np.zeros((1, 5))
        H[0, 4] = 1.0
        R = np.array([[self.r_cog**2]])
        S = H @ self.P @ H.T + R
        K = self.P @ H.T @ np.linalg.inv(S)
        self.x = self.x + K * d
        self.P = (np.eye(5) - K @ H) @ self.P

# =========================
#   Main loop
# =========================
def main():
    bus = smbus.SMBus(I2C_BUS)

    imu = MPU6050(bus)
    imu.calibrate(seconds=3.0, hz=200)

    mag = HMC5883L(bus, addr=MAG_ADDR)

    ahrs = MadgwickAHRS(beta=0.08)

    gps = GPSReader(port=GPS_PORT, baud=GPS_BAUD)
    frame = LocalFrame()
    ekf = EKF2D()

    print("\n[run] Starting. Waiting for first valid GPS fix to set local origin...")

    # Wait for GPS fix to set origin
    while True:
        fix = gps.read_once()
        if fix and ("lat" in fix) and ("lon" in fix) and fix.get("sats", 0) >= 4:
            frame.set_origin(fix["lat"], fix["lon"])
            x0, y0 = frame.ll_to_xy(fix["lat"], fix["lon"])
            ekf.x[0, 0] = x0
            ekf.x[1, 0] = y0
            print(f"[gps] origin set: lat0={fix['lat']:.6f}, lon0={fix['lon']:.6f}  sats={fix.get('sats')}")
            break
        time.sleep(0.05)

    last = time.time()
    while True:
        now = time.time()
        dt = now - last
        last = now
        if dt <= 0 or dt > 0.2:
            dt = 0.01

        # IMU
        acc_g, gyro_rads = imu.read()
        ax, ay, az = acc_g
        gx, gy, gz = gyro_rads

        # MAG (raw units OK, we normalize inside Madgwick)
        mx, my, mz = mag.read()

        # AHRS
        ahrs.update(gx, gy, gz, ax, ay, az, mx, my, mz, dt)
        roll, pitch, yaw = ahrs.euler()
        R_bw = ahrs.rotmat()

        # Body accel -> world accel (crude, no gravity removal)
        acc_ms2_body = np.array([ax, ay, az]) * 9.80665
        acc_ms2_world = R_bw @ acc_ms2_body
        ax_w = acc_ms2_world[0]
        ay_w = acc_ms2_world[1]

        # EKF predict
        ekf.predict(ax_w=ax_w, ay_w=ay_w, yaw=yaw, dt=dt)

        # GPS update
        fix = gps.read_once()
        if fix and ("lat" in fix) and ("lon" in fix):
            xg, yg = frame.ll_to_xy(fix["lat"], fix["lon"])
            ekf.update_gps_xy(xg, yg)

            spd = fix.get("spd_kmh", 0.0)
            cog = fix.get("cog_deg", None)
            if cog is not None and spd is not None and spd > 3.0:
                ekf.update_yaw_from_cog(cog)

        # Print at ~10 Hz
        if int(now * 10) != int((now - dt) * 10):
            X = ekf.x.flatten()
            print(
                f"x={X[0]:8.2f} m  y={X[1]:8.2f} m  "
                f"vx={X[2]:6.2f}  vy={X[3]:6.2f}  "
                f"yaw={math.degrees(X[4]):7.2f} deg | "
                f"rpy=({math.degrees(roll):6.1f},{math.degrees(pitch):6.1f},{math.degrees(yaw):6.1f})"
            )

if __name__ == "__main__":
    main()
