#!/usr/bin/env python3
"""
IMU + LiDAR drift-corrected 2D EKF (Raspberry Pi)

- IMU thread:
  * reads MPU6050 + HMC5883L
  * runs Madgwick AHRS -> yaw + rotation matrix
  * transforms accel to world frame, removes gravity
  * EKF predict step: [x, y, vx, vy]

- LiDAR thread:
  * collects full scans
  * ICP between consecutive scans -> delta in LiDAR frame
  * rotates delta into world using IMU yaw
  * accumulates LiDAR odometry pose (xL, yL)
  * EKF update: absolute position correction using (xL, yL)

NOT full SLAM (no loop closure), but reduces drift strongly.

Works with rplidar-roboticia and your /dev/ttyUSB0.
"""

import time
import math
import threading
import numpy as np

# -------------------------
# SMBus import (FIXED)
# -------------------------
# Works inside your venv with smbus2 (you already installed it).
# If smbus2 missing, tries system smbus.
try:
    from smbus2 import SMBus
except ImportError:
    try:
        import smbus  # only if user doesn't have smbus2
        SMBus = smbus.SMBus
    except ImportError as e:
        raise ImportError(
            "No SMBus backend found. Install smbus2 in your venv: pip install smbus2 "
            "OR install system package: sudo apt install python3-smbus"
        ) from e

from rplidar import RPLidar


# =========================
#   CONFIG
# =========================
I2C_BUS = 1
MPU_ADDR = 0x68
MAG_ADDR = 0x1E  # HMC5883L

G = 9.80665

LIDAR_PORT = "/dev/ttyUSB0"
LIDAR_MIN_MM = 150
LIDAR_MAX_MM = 8000
LIDAR_MIN_Q  = 8

SCAN_MIN_POINTS = 120   # lowered so you get scans easier
DOWNSAMPLE_N = 250

# EKF tuning
Q_POS = 0.10            # process noise pos
Q_VEL = 0.50            # process noise vel
R_LIDAR_POS = 0.10      # meters: bigger => trust LiDAR less

# IMU loop
IMU_HZ = 100
MADGWICK_BETA = 0.08


# =========================
#   Helpers
# =========================
def twos16(v: int) -> int:
    return v - 65536 if (v & 0x8000) else v

def clamp(x, a, b):
    return a if x < a else b if x > b else x

def rot2(theta: float) -> np.ndarray:
    c, s = math.cos(theta), math.sin(theta)
    return np.array([[c, -s],
                     [s,  c]], dtype=float)

def polar_to_xy(angle_deg: float, dist_mm: float):
    a = math.radians(angle_deg)
    r = dist_mm / 1000.0
    return r * math.cos(a), r * math.sin(a)

def downsample_points(pts: np.ndarray, n: int = DOWNSAMPLE_N) -> np.ndarray:
    if len(pts) <= n:
        return pts
    idx = np.random.choice(len(pts), n, replace=False)
    return pts[idx]


# =========================
#   MPU6050
# =========================
class MPU6050:
    def __init__(self, bus, addr=MPU_ADDR):
        self.bus = bus
        self.addr = addr

        # Wake
        self.bus.write_byte_data(self.addr, 0x6B, 0x00)
        time.sleep(0.05)

        # Gyro ±250 dps, Acc ±2g
        self.bus.write_byte_data(self.addr, 0x1B, 0x00)
        self.bus.write_byte_data(self.addr, 0x1C, 0x00)
        time.sleep(0.01)

        # I2C bypass for mag
        self.bus.write_byte_data(self.addr, 0x37, 0x02)  # BYPASS_EN
        self.bus.write_byte_data(self.addr, 0x6A, 0x00)  # disable I2C master
        time.sleep(0.01)

        self.acc_lsb_per_g = 16384.0
        self.gyro_lsb_per_dps = 131.0

        self.gyro_bias_dps = np.zeros(3)
        self.acc_bias_g = np.zeros(3)

    def _read_i16(self, reg):
        hi = self.bus.read_byte_data(self.addr, reg)
        lo = self.bus.read_byte_data(self.addr, reg + 1)
        return twos16((hi << 8) | lo)

    def read(self):
        ax = self._read_i16(0x3B)
        ay = self._read_i16(0x3D)
        az = self._read_i16(0x3F)
        gx = self._read_i16(0x43)
        gy = self._read_i16(0x45)
        gz = self._read_i16(0x47)

        acc_g = np.array([ax, ay, az], dtype=float) / self.acc_lsb_per_g
        gyro_dps = np.array([gx, gy, gz], dtype=float) / self.gyro_lsb_per_dps

        acc_g -= self.acc_bias_g
        gyro_dps -= self.gyro_bias_dps

        gyro_rads = np.deg2rad(gyro_dps)
        return acc_g, gyro_rads

    def calibrate(self, seconds=3.0, hz=200):
        n = int(seconds * hz)
        acc_sum = np.zeros(3)
        gyro_sum_dps = np.zeros(3)
        dt = 1.0 / hz

        print(f"[cal] Hold IMU still for {seconds:.1f}s ...")
        for _ in range(n):
            acc_g, gyro_rads = self.read()
            acc_sum += acc_g
            gyro_sum_dps += np.rad2deg(gyro_rads)
            time.sleep(dt)

        acc_mean = acc_sum / n
        gyro_mean_dps = gyro_sum_dps / n

        self.gyro_bias_dps = gyro_mean_dps
        self.acc_bias_g = np.array([acc_mean[0], acc_mean[1], acc_mean[2] - 1.0])

        print("[cal] gyro_bias_dps:", self.gyro_bias_dps)
        print("[cal] acc_bias_g:", self.acc_bias_g)


# =========================
#   HMC5883L
# =========================
class HMC5883L:
    def __init__(self, bus, addr=MAG_ADDR):
        self.bus = bus
        self.addr = addr

        try:
            ida = self.bus.read_byte_data(self.addr, 0x0A)
            idb = self.bus.read_byte_data(self.addr, 0x0B)
            idc = self.bus.read_byte_data(self.addr, 0x0C)
            print("[mag] ID:", chr(ida), chr(idb), chr(idc))
        except Exception as e:
            print("[mag] ID read failed (may still work):", e)

        # config
        self.bus.write_byte_data(self.addr, 0x00, 0x70)  # 8avg, 15Hz
        self.bus.write_byte_data(self.addr, 0x01, 0x20)  # gain
        self.bus.write_byte_data(self.addr, 0x02, 0x00)  # continuous
        time.sleep(0.01)

        self.offset = np.zeros(3)
        self.axis_map = np.array([0, 1, 2])
        self.axis_sign = np.array([1, 1, 1])

        print(f"[mag] HMC5883L ready at 0x{self.addr:02X}")

    def read_raw(self):
        data = self.bus.read_i2c_block_data(self.addr, 0x03, 6)
        x = twos16((data[0] << 8) | data[1])
        z = twos16((data[2] << 8) | data[3])
        y = twos16((data[4] << 8) | data[5])
        return np.array([x, y, z], dtype=float)

    def read(self):
        m = self.read_raw()
        m = (m - self.offset)
        m = m[self.axis_map] * self.axis_sign
        return m


# =========================
#   Madgwick AHRS
# =========================
class MadgwickAHRS:
    def __init__(self, beta=MADGWICK_BETA):
        self.beta = beta
        self.q = np.array([1.0, 0.0, 0.0, 0.0], dtype=float)  # [w,x,y,z]

    def update(self, gx, gy, gz, ax, ay, az, mx, my, mz, dt):
        # normalize accel
        n = math.sqrt(ax*ax + ay*ay + az*az)
        if n < 1e-9:
            return
        ax, ay, az = ax/n, ay/n, az/n

        # normalize mag
        n = math.sqrt(mx*mx + my*my + mz*mz)
        if n < 1e-9:
            return
        mx, my, mz = mx/n, my/n, mz/n

        q1, q2, q3, q4 = self.q

        hx = 2*mx*(0.5 - q3*q3 - q4*q4) + 2*my*(q2*q3 - q1*q4) + 2*mz*(q2*q4 + q1*q3)
        hy = 2*mx*(q2*q3 + q1*q4) + 2*my*(0.5 - q2*q2 - q4*q4) + 2*mz*(q3*q4 - q1*q2)
        bx = math.sqrt(hx*hx + hy*hy)
        bz = 2*mx*(q2*q4 - q1*q3) + 2*my*(q3*q4 + q1*q2) + 2*mz*(0.5 - q2*q2 - q3*q3)

        f1 = 2*(q2*q4 - q1*q3) - ax
        f2 = 2*(q1*q2 + q3*q4) - ay
        f3 = 2*(0.5 - q2*q2 - q3*q3) - az
        f4 = 2*bx*(0.5 - q3*q3 - q4*q4) + 2*bz*(q2*q4 - q1*q3) - mx
        f5 = 2*bx*(q2*q3 - q1*q4) + 2*bz*(q1*q2 + q3*q4) - my
        f6 = 2*bx*(q1*q3 + q2*q4) + 2*bz*(0.5 - q2*q2 - q3*q3) - mz

        s1 = (-2*q3)*f1 + (2*q2)*f2 + (-2*bz*q3)*f4 + (-2*bx*q4 + 2*bz*q2)*f5 + (2*bx*q3)*f6
        s2 = (2*q4)*f1 + (2*q1)*f2 + (-4*q2)*f3 + (2*bz*q4)*f4 + (2*bx*q3 + 2*bz*q1)*f5 + (2*bx*q4 - 4*bz*q2)*f6
        s3 = (-2*q1)*f1 + (2*q4)*f2 + (-4*q3)*f3 + (-4*bx*q3 - 2*bz*q1)*f4 + (2*bx*q2 + 2*bz*q4)*f5 + (2*bx*q1 - 4*bz*q3)*f6
        s4 = (2*q2)*f1 + (2*q3)*f2 + (-2*bx*q4 + 2*bz*q2)*f4 + (-2*bx*q1 + 2*bz*q3)*f5 + (2*bx*q2)*f6

        ns = math.sqrt(s1*s1 + s2*s2 + s3*s3 + s4*s4)
        if ns > 1e-9:
            s1, s2, s3, s4 = s1/ns, s2/ns, s3/ns, s4/ns

        qDot1 = 0.5 * (-q2*gx - q3*gy - q4*gz) - self.beta*s1
        qDot2 = 0.5 * ( q1*gx + q3*gz - q4*gy) - self.beta*s2
        qDot3 = 0.5 * ( q1*gy - q2*gz + q4*gx) - self.beta*s3
        qDot4 = 0.5 * ( q1*gz + q2*gy - q3*gx) - self.beta*s4

        q1 += qDot1 * dt
        q2 += qDot2 * dt
        q3 += qDot3 * dt
        q4 += qDot4 * dt

        nq = math.sqrt(q1*q1 + q2*q2 + q3*q3 + q4*q4)
        self.q = np.array([q1, q2, q3, q4], dtype=float) / nq

    def euler(self):
        w, x, y, z = self.q
        sinr = 2*(w*x + y*z)
        cosr = 1 - 2*(x*x + y*y)
        roll = math.atan2(sinr, cosr)

        sinp = 2*(w*y - z*x)
        pitch = math.asin(clamp(sinp, -1, 1))

        siny = 2*(w*z + x*y)
        cosy = 1 - 2*(y*y + z*z)
        yaw = math.atan2(siny, cosy)
        return roll, pitch, yaw

    def rotmat(self):
        w, x, y, z = self.q
        return np.array([
            [1-2*(y*y+z*z), 2*(x*y - z*w), 2*(x*z + y*w)],
            [2*(x*y + z*w), 1-2*(x*x+z*z), 2*(y*z - x*w)],
            [2*(x*z - y*w), 2*(y*z + x*w), 1-2*(x*x+y*y)]
        ], dtype=float)


# =========================
#   EKF: [x,y,vx,vy]
# =========================
class EKF2D:
    def __init__(self):
        self.x = np.zeros((4, 1))
        self.P = np.diag([1.0, 1.0, 1.0, 1.0])**2

    def predict(self, ax_w, ay_w, dt):
        x, y, vx, vy = self.x.flatten()

        x  = x  + vx*dt + 0.5*ax_w*dt*dt
        y  = y  + vy*dt + 0.5*ay_w*dt*dt
        vx = vx + ax_w*dt
        vy = vy + ay_w*dt

        self.x = np.array([[x], [y], [vx], [vy]])

        F = np.eye(4)
        F[0, 2] = dt
        F[1, 3] = dt

        Q = np.diag([Q_POS, Q_POS, Q_VEL, Q_VEL])**2
        self.P = F @ self.P @ F.T + Q

    def update_lidar_xy(self, x_meas, y_meas, r_pos=R_LIDAR_POS):
        z = np.array([[x_meas], [y_meas]])

        H = np.zeros((2, 4))
        H[0, 0] = 1.0
        H[1, 1] = 1.0

        R = np.diag([r_pos, r_pos])**2

        y = z - (H @ self.x)
        S = H @ self.P @ H.T + R
        K = self.P @ H.T @ np.linalg.inv(S)

        self.x = self.x + K @ y
        self.P = (np.eye(4) - K @ H) @ self.P


# =========================
#   ICP 2D (simple)
# =========================
def icp_2d(prev_pts, curr_pts, iters=8, max_corr_dist=0.70):
    src = downsample_points(prev_pts.copy())
    dst = downsample_points(curr_pts.copy())

    if len(src) < 50 or len(dst) < 50:
        return 0.0, 0.0, 0.0, 999.0

    T = np.eye(3)
    fitness = 999.0

    def nearest_neighbors(a, b):
        idx = []
        d2s = []
        for p in a:
            d2 = np.sum((b - p)**2, axis=1)
            j = int(np.argmin(d2))
            idx.append(j)
            d2s.append(d2[j])
        return np.array(idx), np.array(d2s)

    for _ in range(iters):
        idx, d2 = nearest_neighbors(src, dst)
        dist = np.sqrt(d2)
        mask = dist < max_corr_dist
        if np.sum(mask) < 30:
            break

        A = src[mask]
        B = dst[idx[mask]]

        ca = A.mean(axis=0)
        cb = B.mean(axis=0)
        AA = A - ca
        BB = B - cb

        Hm = AA.T @ BB
        U, _, Vt = np.linalg.svd(Hm)
        Rm = Vt.T @ U.T
        if np.linalg.det(Rm) < 0:
            Vt[1, :] *= -1
            Rm = Vt.T @ U.T

        t = cb - Rm @ ca

        src = (Rm @ src.T).T + t

        Ti = np.eye(3)
        Ti[:2, :2] = Rm
        Ti[:2,  2] = t
        T = Ti @ T

        fitness = float(np.mean(dist[mask]))

    dx = float(T[0, 2])
    dy = float(T[1, 2])
    dtheta = math.atan2(float(T[1, 0]), float(T[0, 0]))
    return dx, dy, dtheta, fitness


# =========================
#   LiDAR scan helpers
# =========================
def scan_to_points(scan):
    pts = []
    for q, angle, dist in scan:
        if q < LIDAR_MIN_Q:
            continue
        if dist <= 0:
            continue
        if dist < LIDAR_MIN_MM or dist > LIDAR_MAX_MM:
            continue
        x, y = polar_to_xy(angle, dist)
        pts.append([x, y])
    if len(pts) < SCAN_MIN_POINTS:
        return None
    return np.array(pts, dtype=float)

def lidar_scan_iterator(lidar: RPLidar):
    # Prefer iter_scans if available
    if hasattr(lidar, "iter_scans"):
        for scan in lidar.iter_scans():
            yield scan  # list of (q, angle, dist)
    # Fallback to iter_measures (your version likely)
    elif hasattr(lidar, "iter_measures"):
        buf = []
        for new_scan, q, angle, dist in lidar.iter_measures():
            buf.append((q, angle, dist))
            if new_scan and buf:
                yield buf
                buf = []
    else:
        raise RuntimeError("No iter_scans or iter_measures found in your rplidar package.")


# =========================
#   Shared state
# =========================
class Shared:
    def __init__(self):
        self.lock = threading.Lock()
        self.roll = 0.0
        self.pitch = 0.0
        self.yaw = 0.0


# =========================
#   IMU thread
# =========================
def imu_loop(stop_evt, shared: Shared, ekf: EKF2D):
    bus = SMBus(I2C_BUS)

    imu = MPU6050(bus)
    imu.calibrate(seconds=3.0, hz=200)

    mag = HMC5883L(bus, addr=MAG_ADDR)
    ahrs = MadgwickAHRS(beta=MADGWICK_BETA)

    dt_target = 1.0 / IMU_HZ
    last = time.time()

    print("[imu] Running IMU loop...")

    while not stop_evt.is_set():
        now = time.time()
        dt = now - last
        if dt <= 0 or dt > 0.2:
            dt = dt_target
        last = now

        try:
            acc_g, gyro_rads = imu.read()
            mx, my, mz = mag.read()

            ax, ay, az = acc_g
            gx, gy, gz = gyro_rads

            ahrs.update(gx, gy, gz, ax, ay, az, mx, my, mz, dt)
            roll, pitch, yaw = ahrs.euler()
            R_bw = ahrs.rotmat()

            # body accel -> world accel
            acc_ms2_body = np.array([ax, ay, az], dtype=float) * G
            acc_ms2_world = R_bw @ acc_ms2_body
            acc_ms2_world[2] -= G

            ax_w = float(acc_ms2_world[0])
            ay_w = float(acc_ms2_world[1])

            with shared.lock:
                shared.roll = roll
                shared.pitch = pitch
                shared.yaw = yaw

            # EKF predict
            ekf.predict(ax_w, ay_w, dt)

        except Exception as e:
            print("[imu] Error:", e)

        time.sleep(max(0.0, dt_target - (time.time() - now)))

    print("[imu] Stopped.")


# =========================
#   LiDAR thread
# =========================
def lidar_loop(stop_evt, shared: Shared, ekf: EKF2D):
    lidar = RPLidar(LIDAR_PORT)
    print("[lidar] info:", lidar.get_info())
    print("[lidar] health:", lidar.get_health())
    print("[lidar] Running scan loop...")

    prev_pts = None
    xL, yL = 0.0, 0.0

    last_print = 0.0

    try:
        for scan in lidar_scan_iterator(lidar):
            if stop_evt.is_set():
                break

            pts = scan_to_points(scan)
            if pts is None:
                continue

            if prev_pts is not None:
                dx, dy, _, fit = icp_2d(prev_pts, pts)

                with shared.lock:
                    yaw = shared.yaw

                d_world = rot2(yaw) @ np.array([dx, dy], dtype=float)
                xL += float(d_world[0])
                yL += float(d_world[1])

                # EKF correction using LiDAR odom pose
                ekf.update_lidar_xy(xL, yL, r_pos=R_LIDAR_POS)

                now = time.time()
                if now - last_print > 0.2:
                    last_print = now
                    X = ekf.x.flatten()
                    print(
                        f"[ekf] x={X[0]:7.2f} y={X[1]:7.2f} vx={X[2]:6.2f} vy={X[3]:6.2f} | "
                        f"[lidar] xL={xL:7.2f} yL={yL:7.2f} fit={fit:5.3f} yaw={math.degrees(yaw):6.1f}"
                    )

            prev_pts = pts

    except Exception as e:
        print("[lidar] Error:", e)

    finally:
        try:
            lidar.stop()
            lidar.stop_motor()
            lidar.disconnect()
        except Exception:
            pass
        print("[lidar] Stopped.")


# =========================
#   Main
# =========================
def main():
    shared = Shared()
    ekf = EKF2D()
    stop_evt = threading.Event()

    t_imu = threading.Thread(target=imu_loop, args=(stop_evt, shared, ekf), daemon=True)
    t_lidar = threading.Thread(target=lidar_loop, args=(stop_evt, shared, ekf), daemon=True)

    t_imu.start()
    time.sleep(0.5)
    t_lidar.start()

    print("\n[run] Running. Press Ctrl+C to stop.\n")
    try:
        while True:
            time.sleep(0.5)
    except KeyboardInterrupt:
        print("\n[run] Stopping...")
        stop_evt.set()
        time.sleep(0.5)

    print("[run] Done.")


if __name__ == "__main__":
    main()
